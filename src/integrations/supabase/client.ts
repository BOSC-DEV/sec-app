// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { sanitizeInput } from '@/utils/securityUtils';

const SUPABASE_URL = "https://mfirlsuuxpvgwaxymjor.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maXJsc3V1eHB2Z3dheHltam9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMyNDIyNjQsImV4cCI6MjA1ODgxODI2NH0.NCYmYYwlpwGieEd3VwrnWCKsva6Wl6Tw1ouTBmfSO-I";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storageKey: 'supabase-auth',
    detectSessionInUrl: false, // Disable automatic detection of OAuth redirects
  },
  global: {
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Info': 'sec-community-app',
    },
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Helper function to secure fetch requests to Supabase
export const secureFetch = async (url: string, options: RequestInit = {}) => {
  // Sanitize URL to prevent header injection
  const sanitizedUrl = sanitizeInput(url);
  
  // Apply default security headers
  const secureOptions = {
    ...options,
    headers: {
      ...options.headers,
      'Content-Security-Policy': "default-src 'self'",
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
      'Referrer-Policy': 'strict-origin-when-cross-origin'
    },
  };
  
  return fetch(sanitizedUrl, secureOptions);
};

// Helper function to safely insert data with RLS validation
export const safeInsert = async <T extends keyof Database['public']['Tables']>(
  table: T,
  data: Database['public']['Tables'][T]['Insert'],
  options?: { returning?: 'minimal' | 'representation' }
) => {
  // Clone data to avoid modifying original
  const sanitizedData = { ...data } as any;
  
  // Sanitize all string fields to prevent XSS and SQL injection
  Object.keys(sanitizedData).forEach(key => {
    if (typeof sanitizedData[key] === 'string') {
      sanitizedData[key] = sanitizeInput(sanitizedData[key]);
    }
  });
  
  // Insert the data with returning option
  const result = supabase
    .from(table)
    .insert(sanitizedData);
    
  if (options?.returning) {
    return result.select();
  }
  
  return result;
};

// Authenticate with wallet by verifying a signature via a secure backend or edge function,
// and receiving a custom Supabase JWT token.
export async function signInWithCustomToken(walletAddress: string, signedMessage: string, nonce: string) {
  try {
    // First check if there's an existing session
    const { data: { session: existingSession } } = await supabase.auth.getSession();
    if (existingSession?.user?.email?.split('@')[0].toLowerCase() === walletAddress.toLowerCase()) {
      console.log('Already authenticated with this wallet');
      return true;
    }

    // If there's a different session, sign out first
    if (existingSession) {
      await supabase.auth.signOut();
    }

    // Call the edge function to get the JWT tokens
    const { data, error } = await supabase.functions.invoke('login-wallet', {
      body: JSON.stringify({ 
        walletAddress, 
        signedMessage, 
        nonce 
      }),
    });
    
    if (error) {
      console.error('[Edge Function Error]', error);
      throw new Error('Failed to call login-wallet function');
    }
    
    if (data?.error_code || data?.msg) {
      console.warn('[Wallet Auth Error]', data);
      throw new Error(data.msg || 'Login failed');
    }
    
    const { access_token, refresh_token } = data;
    
    // Set up session with retry mechanism
    let retries = 3;
    let success = false;
    let lastError = null;
    
    while (retries > 0 && !success) {
      try {
        const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
          access_token,
          refresh_token,
        });
        
        if (sessionError) throw sessionError;
        
        if (sessionData.session) {
          // Verify the session is valid
          const { data: { user }, error: userError } = await supabase.auth.getUser();
          
          if (userError) throw userError;
          
          if (user?.email?.split('@')[0].toLowerCase() === walletAddress.toLowerCase()) {
            success = true;
            break;
          } else {
            throw new Error('Session user does not match wallet address');
          }
        }
      } catch (err) {
        lastError = err;
        console.warn(`Failed to set session, retries left: ${retries - 1}`, err);
        retries--;
        
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    if (!success) {
      throw new Error(`Failed to set Supabase session after multiple attempts: ${lastError?.message}`);
    }
    
    console.log('Wallet login successful');
    return true;
  } catch (err) {
    console.error('Error in wallet authentication: ', err);
    return false;
  }
}

// Add a helper function to check authentication status
export const isAuthenticated = async () => {
  const { data: { session } } = await supabase.auth.getSession();
  return !!session;
};

// Add a helper function for authenticated data fetching with retry logic
export const authenticatedQuery = async <T>(
  queryFn: () => Promise<{ data: T | null; error: any }>,
  maxRetries = 3
): Promise<{ data: T | null; error: any }> => {
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      // Check authentication before making the query
      const authenticated = await isAuthenticated();
      if (!authenticated) {
        console.warn('Not authenticated, waiting for session...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        retries++;
        continue;
      }
      
      const result = await queryFn();
      
      if (!result.error) {
        return result;
      }
      
      // If error is related to auth, retry
      if (result.error.code === 'PGRST301' || result.error.message?.includes('JWT')) {
        console.warn('Auth error, retrying...', result.error);
        await new Promise(resolve => setTimeout(resolve, 1000));
        retries++;
        continue;
      }
      
      return result;
    } catch (error) {
      console.error('Query error:', error);
      return { data: null, error };
    }
  }
  
  return { data: null, error: new Error('Max retries reached') };
};

// Helper function to check if authentication is required for an operation
export const requiresAuth = async (operation: 'read' | 'write' | 'admin', throwError: boolean = true): Promise<boolean> => {
  const authenticated = await isAuthenticated();
  
  if (!authenticated && throwError) {
    throw new Error(`Authentication required for ${operation} operation`);
  }
  
  return authenticated;
};

// Helper function to safely execute Supabase queries with authentication checks
export const safeQuery = async <T>(
  operation: 'read' | 'write' | 'admin',
  queryFn: () => Promise<{ data: T | null; error: any }>,
  options: { 
    fallbackValue?: T | null;
    bypassAuth?: boolean;
    maxRetries?: number;
  } = {}
): Promise<{ data: T | null; error: any }> => {
  const { fallbackValue = null, bypassAuth = false, maxRetries = 3 } = options;
  
  try {
    // Check authentication if required
    if (!bypassAuth) {
      const authenticated = await requiresAuth(operation, false);
      if (!authenticated) {
        return { 
          data: fallbackValue, 
          error: new Error(`Authentication required for ${operation} operation`) 
        };
      }
    }
    
    // Use the existing authenticatedQuery for the actual query
    return await authenticatedQuery(queryFn, maxRetries);
  } catch (error) {
    console.error(`Error in ${operation} operation:`, error);
    return { data: fallbackValue, error };
  }
};
