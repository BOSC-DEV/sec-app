// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { sanitizeInput } from '@/utils/securityUtils';

const SUPABASE_URL = "https://mfirlsuuxpvgwaxymjor.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maXJsc3V1eHB2Z3dheHltam9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMyNDIyNjQsImV4cCI6MjA1ODgxODI2NH0.NCYmYYwlpwGieEd3VwrnWCKsva6Wl6Tw1ouTBmfSO-I";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storageKey: 'supabase-auth',
    detectSessionInUrl: false, // Disable automatic detection of OAuth redirects
  },
  global: {
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Info': 'sec-community-app',
    },
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Helper function to secure fetch requests to Supabase
export const secureFetch = async (url: string, options: RequestInit = {}) => {
  // Sanitize URL to prevent header injection
  const sanitizedUrl = sanitizeInput(url);
  
  // Apply default security headers
  const secureOptions = {
    ...options,
    headers: {
      ...options.headers,
      'Content-Security-Policy': "default-src 'self'",
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
      'Referrer-Policy': 'strict-origin-when-cross-origin'
    },
  };
  
  return fetch(sanitizedUrl, secureOptions);
};

// Helper function to safely insert data with RLS validation
export const safeInsert = async <T>(
  table: keyof Database['public']['Tables'],
  data: any,
  options?: { returning?: 'minimal' | 'representation' }
) => {
  // Clone data to avoid modifying original
  const sanitizedData = { ...data };
  
  // Sanitize all string fields to prevent XSS and SQL injection
  Object.keys(sanitizedData).forEach(key => {
    if (typeof sanitizedData[key] === 'string') {
      sanitizedData[key] = sanitizeInput(sanitizedData[key]);
    }
  });
  
  // Insert the data with returning option
  const result = supabase
    .from(table)
    .insert(sanitizedData);
    
  if (options?.returning) {
    return result.select();
  }
  
  return result;
};

// Authenticate with wallet by verifying a signature via a secure backend or edge function,
// and receiving a custom Supabase JWT token.
export async function signInWithCustomToken(walletAddress: string, signedMessage: string, nonce: string) {
  try {
    // First check if there's an existing session
    const { data: { session: existingSession } } = await supabase.auth.getSession();
    if (existingSession?.user?.email?.split('@')[0].toLowerCase() === walletAddress.toLowerCase()) {
      console.log('Already authenticated with this wallet');
      return true;
    }

    // If there's a different session, sign out first
    if (existingSession) {
      await supabase.auth.signOut();
    }

    // Call the edge function to get the JWT tokens
    const { data, error } = await supabase.functions.invoke('login-wallet', {
      body: JSON.stringify({ 
        walletAddress, 
        signedMessage, 
        nonce 
      }),
    });
    
    if (error) {
      console.error('[Edge Function Error]', error);
      throw new Error('Failed to call login-wallet function');
    }
    
    if (data?.error_code || data?.msg) {
      console.warn('[Wallet Auth Error]', data);
      throw new Error(data.msg || 'Login failed');
    }
    
    const { access_token, refresh_token } = data;
    
    // Set up session with retry mechanism
    let retries = 3;
    let success = false;
    let lastError = null;
    
    while (retries > 0 && !success) {
      try {
        const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
          access_token,
          refresh_token,
        });
        
        if (sessionError) throw sessionError;
        
        if (sessionData.session) {
          // Verify the session is valid
          const { data: { user }, error: userError } = await supabase.auth.getUser();
          
          if (userError) throw userError;
          
          if (user?.email?.split('@')[0].toLowerCase() === walletAddress.toLowerCase()) {
            success = true;
            break;
          } else {
            throw new Error('Session user does not match wallet address');
          }
        }
      } catch (err) {
        lastError = err;
        console.warn(`Failed to set session, retries left: ${retries - 1}`, err);
        retries--;
        
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    if (!success) {
      throw new Error(`Failed to set Supabase session after multiple attempts: ${lastError?.message}`);
    }
    
    console.log('Wallet login successful');
    return true;
  } catch (err) {
    console.error('Error in wallet authentication: ', err);
    return false;
  }
}