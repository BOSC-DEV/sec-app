
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { sanitizeInput } from '@/utils/securityUtils';

const SUPABASE_URL = "https://mfirlsuuxpvgwaxymjor.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maXJsc3V1eHB2Z3dheHltam9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMyNDIyNjQsImV4cCI6MjA1ODgxODI2NH0.NCYmYYwlpwGieEd3VwrnWCKsva6Wl6Tw1ouTBmfSO-I";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storageKey: 'supabase-auth',
    detectSessionInUrl: false, // Disable automatic detection of OAuth redirects
    flowType: 'implicit', // Add this to disable email confirmation
  },
  global: {
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Info': 'sec-community-app',
      'apikey': SUPABASE_PUBLISHABLE_KEY,
      'Prefer': 'return=representation' // Request the updated record in response
    },
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Storage client for uploading and downloading files
export const supabaseStorage = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storageKey: 'supabase-auth',
    detectSessionInUrl: false, // Disable automatic detection of OAuth redirects
    flowType: 'implicit', // Add this to disable email confirmation
  },
  global: {
    headers: {
      'X-Client-Info': 'sec-community-app',
      'apikey': SUPABASE_PUBLISHABLE_KEY
    },
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Helper function to secure fetch requests to Supabase
export const secureFetch = async (url: string, options: RequestInit = {}) => {
  // Sanitize URL to prevent header injection
  const sanitizedUrl = sanitizeInput(url);
  
  // Apply default security headers
  const secureOptions = {
    ...options,
    headers: {
      ...options.headers,
      'Content-Security-Policy': "default-src 'self'",
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
      'Referrer-Policy': 'strict-origin-when-cross-origin'
    },
  };
  
  return fetch(sanitizedUrl, secureOptions);
};

// Rate limiting for authentication attempts
const authAttempts = new Map<string, { count: number; lastAttempt: number }>();
const MAX_AUTH_ATTEMPTS = 5;
const RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes

const checkAuthRateLimit = (walletAddress: string): boolean => {
  const now = Date.now();
  const key = walletAddress.toLowerCase();
  const attempts = authAttempts.get(key);
  
  if (!attempts) {
    authAttempts.set(key, { count: 1, lastAttempt: now });
    return true;
  }
  
  // Reset if window has passed
  if (now - attempts.lastAttempt > RATE_LIMIT_WINDOW) {
    authAttempts.set(key, { count: 1, lastAttempt: now });
    return true;
  }
  
  // Check if limit exceeded
  if (attempts.count >= MAX_AUTH_ATTEMPTS) {
    console.warn(`Rate limit exceeded for wallet: ${walletAddress}`);
    return false;
  }
  
  // Increment attempts
  attempts.count++;
  attempts.lastAttempt = now;
  return true;
};

const resetAuthRateLimit = (walletAddress: string): void => {
  authAttempts.delete(walletAddress.toLowerCase());
};

// Generate a secure, deterministic password for wallet authentication
const generateSecureWalletPassword = (walletAddress: string, message: string): string => {
  // Use a combination of wallet address and a fixed salt for deterministic but secure password
  const salt = 'SEC_WALLET_AUTH_2024';
  const combined = `${walletAddress}:${salt}:${message}`;
  
  // Simple hash function (in production, use a proper crypto library)
  let hash = 0;
  for (let i = 0; i < combined.length; i++) {
    const char = combined.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Convert to a more secure string format
  return Math.abs(hash).toString(36) + walletAddress.slice(-8);
};

// Wallet authentication function for Supabase
export const authenticateWallet = async (
  walletAddress: string, 
  signedMessage: string,
  message: string
): Promise<boolean> => {
  if (!walletAddress || !signedMessage) {
    console.error("Missing required parameters for wallet authentication");
    return false;
  }

  // Check rate limiting
  if (!checkAuthRateLimit(walletAddress)) {
    console.error("Rate limit exceeded for wallet authentication");
    return false;
  }

  try {
    console.log("Authenticating wallet:", walletAddress);
    
    // First check if a user exists with this wallet address
    const { data: existingUser, error: userCheckError } = await supabase
      .from('profiles')
      .select('*')
      .eq('wallet_address', walletAddress)
      .maybeSingle();
      
    if (userCheckError) {
      console.error("Error checking for existing user:", userCheckError);
    }
    
    // Generate a consistent email format that will be used for auth
    const walletEmail = `${walletAddress.toLowerCase()}@sec.digital`;
    
    // Generate secure password using wallet address and message
    const securePassword = generateSecureWalletPassword(walletAddress, message);
    
    // Try to sign in first
    const { data, error } = await supabase.auth.signInWithPassword({
      email: walletEmail,
      password: securePassword,
    });

    if (error) {
      console.log("Sign in failed, trying sign up:", error.message);
      
      // If sign in fails, try sign up
      const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
        email: walletEmail,
        password: securePassword,
        options: {
          data: {
            wallet_address: walletAddress,
          }
        }
      });

      if (signUpError) {
        console.error("Error in wallet signup:", signUpError);
        return false;
      }
      
      console.log("User signed up successfully");

      // If the user didn't exist in profiles, we need to create a profile
      if (!existingUser) {
        // Create a default profile for the new user
        const { error: profileError } = await supabase
          .from('profiles')
          .insert({
            id: crypto.randomUUID(),
            wallet_address: walletAddress,
            display_name: `User ${walletAddress.substring(0, 6)}`,
            username: `user_${Date.now().toString(36)}`,
            profile_pic_url: '',
            created_at: new Date().toISOString(),
            x_link: '',
            website_link: '',
            bio: '',
            points: 0
          });
          
        if (profileError) {
          console.error("Error creating profile:", profileError);
        } else {
          console.log("Created new profile for wallet");
        }
      }
    } else {
      console.log("User signed in successfully");
    }

    // Reset rate limit on successful authentication
    resetAuthRateLimit(walletAddress);
    return true;
  } catch (error) {
    console.error("Error in wallet authentication:", error);
    return false;
  }
};

// Helper function to safely insert data with RLS validation
export const safeInsert = async <T>(
  table: keyof Database['public']['Tables'],
  data: any,
  options?: { returning?: 'minimal' | 'representation' }
) => {
  // Clone data to avoid modifying original
  const sanitizedData = { ...data };
  
  // Sanitize all string fields to prevent XSS and SQL injection
  Object.keys(sanitizedData).forEach(key => {
    if (typeof sanitizedData[key] === 'string') {
      sanitizedData[key] = sanitizeInput(sanitizedData[key]);
    }
  });
  
  // Insert the data with returning option
  const result = supabase
    .from(table)
    .insert(sanitizedData);
    
  if (options?.returning) {
    return result.select();
  }
  
  return result;
};
