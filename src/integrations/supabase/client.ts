// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { sanitizeInput } from '@/utils/securityUtils';

const SUPABASE_URL = "https://mfirlsuuxpvgwaxymjor.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1maXJsc3V1eHB2Z3dheHltam9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMyNDIyNjQsImV4cCI6MjA1ODgxODI2NH0.NCYmYYwlpwGieEd3VwrnWCKsva6Wl6Tw1ouTBmfSO-I";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storageKey: 'supabase-auth',
    detectSessionInUrl: false, // Disable automatic detection of OAuth redirects
  },
  global: {
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Info': 'sec-community-app',
    },
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Helper function to secure fetch requests to Supabase
export const secureFetch = async (url: string, options: RequestInit = {}) => {
  // Sanitize URL to prevent header injection
  const sanitizedUrl = sanitizeInput(url);
  
  // Apply default security headers
  const secureOptions = {
    ...options,
    headers: {
      ...options.headers,
      'Content-Security-Policy': "default-src 'self'",
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
      'Referrer-Policy': 'strict-origin-when-cross-origin'
    },
  };
  
  return fetch(sanitizedUrl, secureOptions);
};

// Helper function to safely insert data with RLS validation
export const safeInsert = async <T>(
  table: keyof Database['public']['Tables'],
  data: any,
  options?: { returning?: 'minimal' | 'representation' }
) => {
  // Clone data to avoid modifying original
  const sanitizedData = { ...data };
  
  // Sanitize all string fields to prevent XSS and SQL injection
  Object.keys(sanitizedData).forEach(key => {
    if (typeof sanitizedData[key] === 'string') {
      sanitizedData[key] = sanitizeInput(sanitizedData[key]);
    }
  });
  
  // Insert the data with returning option
  const result = supabase
    .from(table)
    .insert(sanitizedData);
    
  if (options?.returning) {
    return result.select();
  }
  
  return result;
};

// Authenticate with wallet by verifying a signature via a secure backend or edge function,
// and receiving a custom Supabase JWT token.
export async function signInWithCustomToken(walletAddress: string, signedMessage: string, nonce: string) {
  try {
    // First check if there's an existing session
    const { data: { session: existingSession } } = await supabase.auth.getSession();
    
    // If we're already authenticated with this wallet, return success
    if (existingSession?.user?.email?.split('@')[0] === walletAddress) {
      console.log('Already authenticated with this wallet');
      return true;
    }

    // If there's a different session, sign out first
    if (existingSession) {
      console.log('Signing out of existing session');
      await supabase.auth.signOut();
      
      // Wait a bit to ensure the signout is complete
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    console.log('Calling login-wallet function');
    const { data, error } = await supabase.functions.invoke('login-wallet', {
      body: JSON.stringify({ walletAddress, signedMessage, nonce }),
    });
    
    if (error) {
      console.error('[Edge Function Error]', error);
      throw new Error('Failed to call login-wallet function');
    }
    
    if (data?.error_code || data?.msg) {
      console.warn('[Wallet Auth Error]', data);
      throw new Error(data.msg || 'Login failed');
    }
    
    const { access_token, refresh_token } = data;
    
    // Try setting the session multiple times if needed
    let retries = 3;
    let success = false;
    let lastError = null;
    
    while (retries > 0 && !success) {
      try {
        console.log(`Setting session, attempt ${4 - retries}/3`);
        const { error: authError } = await supabase.auth.setSession({
          access_token,
          refresh_token,
        });
        
        if (!authError) {
          success = true;
          break;
        }
        
        lastError = authError;
        console.warn(`Failed to set session, retries left: ${retries - 1}`, authError);
        retries--;
        
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      } catch (error) {
        lastError = error;
        console.error('Error setting session:', error);
        retries--;
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    if (!success) {
      console.error('Failed to set session after all retries');
      throw lastError || new Error('Failed to set Supabase session after multiple attempts');
    }
    
    // Verify the session was set correctly
    const { data: { session: newSession } } = await supabase.auth.getSession();
    if (!newSession || newSession.user.email.split('@')[0] !== walletAddress) {
      console.error('Session verification failed');
      throw new Error('Session verification failed after setting');
    }
    
    console.log('Wallet login successful');
    return true;
  } catch (err) {
    console.error('Error in wallet authentication:', err);
    return false;
  }
}